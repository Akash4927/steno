// Based on original source by
// Copyright (c) 2011 Assaf Arkin
// https://github.com/assaf/node-replay

// A matcher is a function that, given a request, returns an appropriate response or nothing.
//
// The most common use case is to calling `Matcher.fromMapping(mapping)`.
//
// The request consists of:
// url     - URL object
// method  - Request method (lower case)
// headers - Headers object (names are lower case)
// body    - Request body (for some requests)
//
// The response consists of:
// version   - HTTP version
// status    - Status code
// headers   - Headers object (names are lower case)
// body      - Array of body parts
// trailers  - Trailers object (names are lower case)

import assert = require('assert');
import URL = require('url');
import jsStringEscape = require('js-string-escape');

interface IMapping {
  request: any;
  response: any;
}

// Simple implementation of a matcher.
//
// To create a matcher from request/response mapping use `fromMapping`.
export class Matcher {

  // Returns new matcher function based on the supplied mapping.
  //
  // Mapping can contain `request` and `response` object. As shortcut, mapping can specify `path` and `method`
  // (optional) directly, and also any of the response properties.
  public static fromMapping(host: any, mapping: any) {
    assert(!!mapping.path !== !!mapping.request, 'Mapping must specify path or request object');

    let matchingRequest;
    if (mapping.path) {
      matchingRequest = {
        method: mapping.method,
        url:    URL.resolve(`http://${host}/`, mapping.path),
      };
    } else if (mapping.request.url instanceof RegExp) {
      matchingRequest = {
        body:     mapping.request.body,
        headers:  mapping.request.headers,
        host,
        method:   mapping.request.method,
        regexp:   mapping.request.url,
      };
    } else {
      matchingRequest = {
        body:     mapping.request.body,
        headers:  mapping.request.headers,
        method:   mapping.request.method,
        url:      URL.resolve(`http://${host}`, mapping.request.url),
      };
    }

    const matcher = new Matcher(matchingRequest, mapping.response || {});

    // tslint:disable-next-line:only-arrow-functions
    return function(request: any) {
      if (matcher.match(request)) {
        return matcher.response;
      }
    };
  }

  public response: any;
  public hostname: any;
  public regexp: any;
  public port: any;
  public path: any;
  public method: any;
  public headers: any;
  public body: any;

  constructor(request: any, response: any) {
    // Map requests to object properties.  We do this for quick matching.
    assert(request.url || request.regexp, 'I need at least a URL to match request to response');
    if (request.regexp) {
      this.hostname = request.hostname;
      this.regexp   = request.regexp;
    } else {
      const url = URL.parse(request.url);
      this.hostname = url.hostname;
      this.port     = url.port;
      this.path     = url.path;
    }

    this.method   = (request.method && request.method.toUpperCase()) || 'GET';
    this.headers  = {};
    if (request.headers) {
      for (const name in request.headers) {
        if (request.headers.hasOwnProperty(name)) {
          const value = request.headers[name];
          this.headers[name.toLowerCase()] = value;
        }
      }
    }
    this.body = request.body;

    // Create a normalized response object that we return.
    this.response = {
      body:           response.body ? response.body.slice(0) : [],
      headers:        {},
      statusCode:     response.statusCode && parseInt(response.statusCode, 10) || 200,
      statusMessage:  response.statusMessage || '',
      trailers:       {},
      version:        response.version || '1.1',
    };

    // Copy over header to response, downcase header names.
    if (response.headers) {
      const headers = this.response.headers;
      for (const name in response.headers) {
        if (response.headers.hasOwnProperty(name)) {
          const value = response.headers[name];
          headers[name.toLowerCase()] = value;
        }
      }
    }
    // Copy over trailers to response, downcase trailers names.
    if (response.trailers) {
      const trailers = this.response.trailers;
      for (const name in response.trailers) {
        if (response.trailers.hasOwnProperty(name)) {
          const value = response.trailers[name];
          trailers[name.toLowerCase()] = value;
        }
      }
    }
  }

  // Quick and effective matching.
  public match(request: any) {
    const { url, method, headers, body } = request;
    if (this.hostname && this.hostname !== url.hostname) {
      return false;
    }
    if (this.regexp) {
      if (!this.regexp.test(url.path)) {
        return false;
      }
    } else {
      if (this.port && this.port !== url.port) {
        return false;
      }
      if (this.path && this.path !== url.path) {
        return false;
      }
    }
    if (this.method !== method) {
      return false;
    }

    for (const name in this.headers) {
      if (this.headers[name] !== headers[name]) {
        return false;
      }
    }
    if (body) {
      let data = '';
      for (const chunks of body) {
        data += chunks[0];
      }
      data = jsStringEscape(data);
      if (this.body && this.body !== data) {
        return false;
      }
    }
    return true;
  }

};
